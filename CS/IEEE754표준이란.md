# CS

- IEEE 754 부동소수점 표준과 컴퓨터에서의 숫자 표현
    
    ✅ IEEE754란 ? 
          (Institute of Electrical and Electronics Engineers, IEEE)는 전기전자공학 전문가들의 국제조직)
    
    ### 왜 IEEE 754 표준이 도입되었는가?
    
    - 원래 다양한 부동소수점 표현 방식이 존재했으나. 각기 다른 시스템은 서로 다른 방식으로 실수를 표현하고 연산했기 때문에, 소프트웨어가 특정 하드웨어에 종속되는 문제가 발생.
    - 따라서, 다양한 시스템 간의 일관된 실수 표현과 연산을 보장할 표준이 필요했음. 
    이를 통해 소프트웨어의 이식성을 높이고, 계산의 신뢰성을 확보할 수 있었음.
    - **결과**: IEEE 754 표준은 이러한 문제를 해결하기 위해 제정됨!!.
    이는 부동소수점 수의 표현과 연산을 표준화하여 일관성과 호환성을 보장함.
    <br><br>
    
    <aside>
    💡 IEEE 754 표준은 <b>부동소수점 숫자를 컴퓨터에서 어떻게 표현할지에</b> 대한 국제 표준. 
    이 표준은 주로 <b>컴퓨터 과학, 전자공학 분야</b>에서 널리 사용됨. 
     주로 실수의 정확하고 일관된 표현과 연산을 보장하기 위해 도입됨.
    
    </aside>
    
    이를 이해하기 위해서는 우선 **컴퓨터 계산의 오차**에 대해서 먼저 알아야 해욤. 
    <br><br>
    ✅ 컴퓨터에서의 숫자 표현과 오차
    
    <aside>
    💡 컴퓨터에서 숫자를 표현하는 과정에서는 불가피하게 오차가 발생할 수 있습니담. 
    왜냐하면 컴퓨터는 유한한 비트를 사용하여 무한한 실수를 표현해야 하기 때문입니다.
    그게 무슨말이냐
    <br><br>
    ⚠️ 오차의 대표적인 예
    
    예를 들어, 아래 계산식을 보면 
    
    ```jsx
    System.out.println(0.1 + 0.2); => Java
    console.log(0.1+0.2);          => JavaScript
    print(0.1+0.2);                => python
    ```
    
    ⇒ 이에 대한 값이 0.3이 나오길 기대하지만 현실은 이케 하면 0.30000000000000004 나옴
    
    ❓왜 
          ⇒ 사실 각각의 값이 진짜 0.1과 0.2가 아니기 때문임. 
          <br>
    ❓왜 아닌데
         ⇒컴퓨터는 **이진법**을 사용해서 숫자를 비롯한 모든 데이터를 표현하고 처리함. 
            하지만 이 방식으로는 모든 숫자를 정확하게 표현 못함!! 
            <br>
    ❓왜 정확하게 표현 못하는데 
         ⇒ 간단한 예시를 들자면, 이진법 전에 우리가 쓰는 십진법을 먼저 봐보자.  
             3/1(3분의1)을 십진 소수점 수로 어떻게 나타내요
            
    
    
    ![스크린샷 2024-06-24 오후 11.58.14.png](/CS/img/ieee754(1).png)
    
    0.333333333333333…. 으로 무한소수가 됩니당. 
    아무리 나눠도 3/1에는 딱 나눠지지 않음. 
    그래서 보통은 무한으로 333333 나올 수는 없으니까 그냥 
    0.333 하고 끊음. 
    
    ![스크린샷 2024-06-25 오전 12.02.16.png](/CS/img/ieee754(2).png)
    
    그럼 사실 끊은만큼 나머지 수에 대한 오차가 생기는 것임. 
    
    마찬가지로 컴터에서도 제대로 숫자가 표현이 안되는 게 있다는 거다...
    
    예를 들어, 
    <br>
    
    ### 딱 떨어지는 수
    
    십진법에서 9.625로 표기되는 이 정수가 아닌 실수를 이진법으로 바꾸면
    
    이진수로 1001.101로 표현됨. 
    ⇒ 아래는 왜 1001.101인지를 쓴 식. 
    <br>
    
    ### 정수 부분 변환
    
    9는 2의 0승과 2의 3승의 합이기 때문에 1001임.  
    
    ```jsx
    9 / 2 = 4 나머지 1
    4 / 2 = 2 나머지 0 
    2 / 2 = 1 나머지 0
    1 / 2 = 0 나머지 1
    ```
    
    ### 소수 부분 변환
    
    이번에는 소수 부분인 0.625를 이진수로 변환해보겠음. 
    
    소수 부분은 2를 곱하여 정수 부분을 차례로 구하는 방식으로 변환함. 
    
    ```jsx
    0.625 × 2 = 1.25  → 정수 부분은 1
    0.25  × 2 = 0.5   → 정수 부분은 0
    0.5   × 2 = 1.0   → 정수 부분은 1
    ```
    
    ⇒ 이제 정수 부분을 차례로 나열하면 101이 됩니당. 
    즉, 소수 부분 0.625는 이진수로 0.101입니다.
    
    ### 따라서, 십진수 9.625는 ⇒ 이진수로 1001.101로 표현.
    
    다행히도 이렇게 딱 떨어지는 실수도 있는가 하면, 
    
    ### 딱 떨어지지 않는 수
    
    0.1마냥 정확한 값을 가지지 않는 무한 소수도 있다. 
    
    ⇒ 아래를 참고 
    
     십진수의 0.1을 2진수로 나타내면
    
    ```jsx
    0.1 × 2 = 0.2 → 정수 부분은 0
    0.2 × 2 = 0.4 → 정수 부분은 0
    0.4 × 2 = 0.8 → 정수 부분은 0
    0.8 × 2 = 1.6 → 정수 부분은 1
    0.6 × 2 = 1.2 → 정수 부분은 1
    0.2 × 2 = 0.4 → 정수 부분은 0
    ...
    ```
    
    보시는 바와 같이,,, 보통 0.1에 가까워지기만 할 뿐 맞아 떨어지지는 않음. 
    2진법에선 1/10이 무한 소수가 된다는 거당. 
     
    <br>
    </aside>
    
    ✅ 그럼 이제 컴퓨터가 데이터를 어떻게 저장 하는지 방법을 보자 
    
    <aside>
    💡    <mark>1️⃣ int (정수 자료형)</mark><br>
                ⇒ int는 32 bit를 사용함 즉,  <br>
                ⇒ 0또는 1이 들어가는 자리 32개를 쓴다는 뜻<br><Br>
            <span style="color:red;">ㅁ</span>ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ
            <br><Br>
    ⇒ 이런 32bit를 사용하는데, 
        이중 빨간 첫번째 자리는 + 혹은 -를 나타냄 . 
        <b>부호를 나타낸다는 뜻.</b> <br> 
        : 0이면 양수, 1이면 음수 

    나머지 31개로 절대값을 표현하는데 <br>
    
    이 둘의 조합으로 <br>
    양수 :    최소 0부터 2의 31승 -1까지<Br>
    음수 : - 31승부터 최대 -1까지 표현
    한다. 
    
    이와같이 32비트 즉, 4바이트로 정수를 표현하는 게 int자료형<br>
    (1바이트가 8비트니깜 !) 이며 <Br>
    이렇게 사용하는 비트를 확장, 축소하기도 하면서 필요한 값에 대한 메모리를 효율적으로 <br>
    사용할 수 있도록 여러 자료형을 제공함. (우리가 아는 바이트, 인트, 등등)<br>
    예를들어, 100점을 넘지않는 학생의 시험점수라면 int 보다는 byte가 더 나은거다. <br>
    ⇒ byte는 -128~127이니까 
    
    그럼,,, 
    정수가 아닌 9.625 같은 이런 숫자들은 엇케 저장하는데 ?
    <br>
    
    <mark>2️⃣ Floating point인 부동소수점</mark>
    
    그런 것들을 표현하기 위한 두 번째 자료형이 
    Floating point인 부동소수점 이다.
    
    ⇒ 이 부동은 **떠서 움직인다는 뜻**으로 소수점이 떠서 움직인단 뜻. 
    
    </aside>
    
    ✋잠깐 이제 여기서 부동소수점과 고정소수점에 대해서 이해할 차례이당. <br>
    
    <aside>
    💡   컴퓨터에서 숫자를 표현하는 방식은 총2가지 이다. <br>
       (컴퓨터는 이진수로 데이터를 처리하기 때문임)<br>
        <span style="background-color: green; padding: 0.2em; color : black">바로 부동소수점과 고정 소수점 </span><br>
       (그 중에서 IEEE754는 부동소수점 수의 표현과 연산을 표준화한 규격인 거고! )<br>
    
    아직 이해가 안 가겠지만, 개념만 대충 설명하자면<br><br>
    1️⃣ 부동소수점 이란 ?<br>
          :부동소수점 방식은 소수점의 위치가 변할 수 있으며, 
            이를 통해 더 넓은 범위의 숫자를 표현할 수 있음. 
            왜냐하면 지수와 가수를 사용하여 숫자를 표현하기 때문.
    
    👍 부동소수점 방식은 과학적 계산이나 공학적 계산에서 널리 사용되며, 
          정밀도가 중요한 계산에 적합함.
    
    ⛔ 하지만, 부동소수점 방식은 표현할 수 있는 숫자의 정밀도에 한계가 있어, 
          계산 과정에서 오차가 발생할 수 있음.
    
    2️⃣ 고정소수점 이란?
          : 고정소수점 방식은 소수점의 위치가 고정되어 있어, 정수와 소수를 분리하여 표현함. 
             이 방식은 간단하고 이해하기 쉽지만, 표현할 수 있는 범위가 제한적임.
                 
    
    3️⃣ 고정소수점과 부동소수점 예시로 다시 한 번 개념 설명.  <br>
          ⇒ 직전의 int 처럼 32 bit 를 가지고 
              123.456과 같은 실수를 저장한다고 치자.
              이 비트들을 어떻게 사용하면 좋을까욤 ??
    
    ✋Case 1. 
         일단 실수에도 플마가 있으니까 <br>
         <span style="color : red;">ㅁ</span>ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ<br>
         <span style="color : red;">첫 비트</span>: 똑같이 양수음수 구분에 쓰고  <br>
         나머지 31비트 : 실수엔 정수 부분이랑 실수부분이 있으니까 15 16 나눠서 반반으로 
         정수 , 소수 부분에 할당하면 ?
    
         ⇒ 이런 방식을 <b>고정소수점</b>이라함. 
         ⛔ 하지만 이 방식에는 31개의 비트를 정수 부분에는 큰 숫자를 표시할 수 없고 
               소수부분에도 정밀한 값 표현 불가능함. 
    
    ❓왜 고정소수점은 표현의 한계가 있는가 ? 에 대한 예시를 들어봅니당.<Br> 
    ==============================예시==============================
    
    ### 정수 부분의 한계
    
    정수 부분의 비트 수가 고정되어 있기 때문에, 표현할 수 있는 정수의 범위가 제한됨. 
    예를 들어, 15비트 정수 부분을 사용하면, 표현할 수 있는 정수의 범위는 다음과 같음:
    
    - 양수: 0부터 215−1까지 (0에서 32767까지)
        
        215−1
        
    - 음수: -1부터 −215까지 (-1에서 -32768까지)
        
        −215
        
    
    이 범위를 벗어나는 정수는 고정소수점 방식으로는 표현할 수 없음.
    
    ### 소수 부분의 한계
    
    소수 부분의 비트 수가 고정되어 있기 때문에, 표현할 수 있는 소수의 정밀도도 제한됨. 
    예를 들어, 16비트 소수 부분을 사용하면, 표현할 수 있는 최소 단위는 다음과 같음:
    
    - 최소 단위: 2−16 (약 0.0000153)
        
        2−16
        
    
    소수 부분이 16비트로 제한되므로, 이보다 더 작은 소수는 표현할 수 없는 것. 
    즉, 소수점 이하 0.0000153 단위로만 표현할 수 있기 때문에, 
    매우 작은 소수를 정확하게 표현하는 데 한계가 있다.
    
    ### 그럼 이 상태로
    
    - 정수 최대값: 32767
    - 정수 최소값: -32768
    - 소수 최소 단위: 0.0000153
    
    만약 우리가 50000이라는 정수를 표현하려고 한다면, 고정소수점 방식으로는 불가능함. 
    마찬가지로, 0.0000001과 같은 매우 작은 소수도 표현할 수 없음.
    
    ====================충분히 이해가 갔을거라 생각하고====================
    
    </aside>
    
    ✅ 부동소수점(floating-point)방식은 이러한 **고정된 크기의 한계를 극복하기 위해 설계**가 됨<br>
    
    <aside>
    💡 1️⃣ 부동 소수점이 소수점 자리를 처리하는 법. 
    일단, 아까 9.625가 1001.101로 변환되는 걸 봤을건데
    부동소수점은 이런 모든 숫자를 <br>
    <b>1. x~~~로 변환함</b>
    <br><br>
    
    ```jsx
    1001.101 => 1.001101
    ```
    
    ⇒ 이렇게 변환된다는 말이다. <br>
        1.001101이 되려면 <br>
        소수점이 왼쪽으로 세 칸 이동해야하자나요 그래서 <br>
        소수점이 떠서 움직여야한다고 한 것입니당. <br>
    
    2️⃣ 부동소수점 숫자의 표현방식 
     - 부호비트  (1비트)
     - 지수 비트 (8비트)
     - 가수 비트 (23비트)
    이렇게 3가지로 표현된다. 
    
    ```jsx
    1. 부호 비트가 의미하는 바.  숫자의 부호이며 0은 양수, 1은 음수 
    2. 지수 비트의 역할 . 숫자의 크기를 나타내며, 편향된 지수로 저장. 
    3. 가수 비트의 역할 . 숫자의 유효숫자를 나타내며, 정규화된 숫자의 경우 숨겨진 1을 가짐. 
    ```
    
    - 편향된 지수가 뭔데요
        
        <aside>
        💡    "바이어스 (bias)라고 합니다"<br>
            바이어스란 지수를 저장할 때 일정한 값을 더해줍니다. 
            사용하는 이유는 : 지수의 표현을 단순하게 만들어 양수와 음수를 동일한 방식으로 
            처리할 수 있게 하기 위함 !! . <br>
            이 값을 더해서 <b>항상 양수로</b> 표현 가능합니다.
        
        </aside>
        <br>
    - 단정밀도와 배정밀도에서 지수 크기가 다른가요 ?
        
        <aside>
        💡 => 단정밀도 : 127
        => 배정밀도 : 1023 
        
        이런값을 선택한 이유를 말해드립니당.<br><br>
        1️⃣단정밀도가 지수 비트가 127인 이유 <br>
        ⇒ 단정밀도의 지수 비트는 8비트잖아요. <br>
        ⇒ 8비트로 표현할 수 있는 값의 범위는 0~255<br>
        ⇒ 지수의 실제 범위는 -126 ~ +127 <br>
        
        이렇게 하면 만약 <br>
        저장된 값이 127일 때 : 실제 지수 = 127 - 127 = 0<br>
        저장된 값이 0일 때 : 실제 지수    = 0  - 127 = -127<br>
        저장된 값이 255일 때. : 실제 지수 = 255 - 127 = 128 <br>
        
        이렇듯, 실제 지수의 값을 양수와 음수로 균등하게 분포시킬 수 있습니당. 
        
        배정밀도도 같은 원리 ^_^
        
        </aside>
        
    
    <span style="color : red;">ㅁ</span><span style="color : yellow;">ㅁㅁㅁㅁㅁㅁㅁㅁ</span><span style="color : green;">ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ</span><br>
    정수 자료형처럼 32비트 중 <span style="color : red;">첫 비트는 양수음수 구분에 사용</span>하고 <br>
    그 다음에 오는 <span style="color : yellow;">8비트로 소숫점이 몇 칸을 움직일지를 나타냄.</span> <br>
     ⇒ 127과의 차이를 움직일 칸의 개수로 나타내는 것. 
    <span style="color : green;">나머지 23자리에 소숫점이 움직인 결과에서 소숫점 뒤로 오는 부분들을 채워넣는 것. </span>
    
    이렇게 하면 23비트를 숫자표현에 사용할 수 있고 
    소숫점의 자리도 필요한 대로 움직일 수 있어서 
    고정소수보다는 효율적으로 비트를 사용해서 다양한 숫자를 표현할 수 있다. 
    
    ```go
    *9.625로 치면*
     
    @ 부호비트  : 0
      => 양수이기 때문에 0이 들어간다.  
    
    @ 지수 비트 :  100000010
      => 1001.101을 정규화하면 1.001101 X 2^3이 됨. 
         (소수점이 왼쪽으로 3칸 이동했기 때문에)
         단정밀도 바이어스 값 : 127
         실제 지수 : 3
         127+3 : 130이고 
         130을 이진수로 변환하면 100000010이기 때문에 
         지수 비트는 100000010의 지수 비트를 가짐. 
    
    @ 가수 비트 : 00110100000000000000000
       => 001101의 수를 23비트로 채우고, 부족한 부분은 0으로 채움
    ```
    
    이처럼, 32비트 중 
    1비트, 8비트, 23비트를 각각 
    부호와 지수, 가수에 할당해서 사용하는 방식이 
    IEEE754표준 방식 !!
    
    <mark>3️⃣IEEE754가 제공하는 형식</mark>
    
         - 단정밀도 : 32비트
         - 배정밀도 : 64비트 ⇒ 부호비트(1비트), 지수비트 (11비트), 가수비트 (52비트)
         이는 각각 32비트와 64비트로 숫자를 표현하며, 
         지수와 가수의 비트 수가 다름. 
    
    - 둘의 장단점은 무엇이며 언제 사용해야 하는지
        
        <aside>
        💡 단정밀도는 <br>
        👍대량의 데이터를 다룰 때 더 적은 메모리를 사용하고 연산 속도가 빠르다는 장점 <br>
        ⛔정밀도와 표현 범위 제한으로 정밀한 계산 혹은 매우 큰 수, 매우 작은 수 표현에는 제한. <Br><br>
        
        배정밀도는
        
        👍높은 정밀도 !! 약 15자리 십진수까지 정밀하게 표현가능하여 과학적 계산, 
        
              금융모델링 등에서 사용, 넓은 범위 표현 가능, 오차 감소 
        ⛔많은 메모리 차지, 연산 속도가 더 느릴 수 있음. <br><br>
        
        언제 뭘 사용해야하는가 ?<br>
        ⇒ 단정밀도 : 메모리 및 성능이 중요한 실시간 그래픽 처리, 게임 개발 등
        
        ⇒ 배정밀도 : 정밀도와 범위가 중요한 과학적, 금융, 기상 예측 등 
        
        </aside>
        
    </aside>
    
    이렇듯… 컴퓨터는 한정된 메모리 공간을 최대한 절약해서 소프트웨어의 수많은 데이터들을 올려두고 연산해야 하기 때문에 오차가 생긴다는 단점이 있으나, 기본적으로 이와 같은 부동소수점 자료형들로 실수들을 표현한당. 
    
    ✅ 그래서 , IEEE 754 표준은 이러한 오차를 최소화하기 위한 여러 가지 방법을 제공함. 
    
    <aside>
    💡 예를 들어, 반올림 방식을 정의하여 계산 결과의 정확도를 높임.
    
    또한, 특수한 값인 NaN(Not a Number)이나 무한대를 표현할 수 있어, 
    
    예외 상황을 처리하는 데 유용합니다.
    
    ### 4️⃣IEEE754에서 정의된 특별한 값이란 ?
    
         a. 무한대
         b. NaN(Not a Number)
    
    - 무한대와 NaN의 도입 배경
        
        **무한대**: 연산 결과가 컴퓨터가 표현할 수 있는 최대값을 초과하는 경우, 
                    이를 처리할 수 있는 값이 필요했음. 
        
        **NaN (Not a Number)**: 연산 결과가 정의되지 않거나 의미가 없는 경우,
        
                                               이를 표시할 수 있는 값이 필요했음.
        
    - 무한대와 NaN의 사용법
        
        ### a. 무한대 (Infinity)
        
        - **정의**: 지수가 모두 1이고, 가수가 0인 경우. 
        (지수가 최대값이며,  추가적인 유효 숫자가 없음)
        - **설명**: 무한대는 매우 큰 값의 연산 결과나 분모가 0인 경우와 같은 특수한 상황에서 사용됨. 예를 들어, 매우 큰 수를 더하거나 곱할 때, 결과가 컴퓨터가 표현할 수 있는 최대 범위를 넘어서면 무한대로 처리됨.
        - **예시**: ∞ 또는 −∞.∞,−∞
        
        ### b. NaN (Not a Number)
        
        - **정의**: 지수가 모두 1이고, 가수가 0이 아닌 경우.
        - **설명**: NaN은 연산 결과가 정의되지 않거나 의미가 없을 때 발생.
        
               이는 예를 들어, 0을 0으로 나누는 경우나, 음수의 제곱근을 계산할 때 발생할 수 있음.
        
        - **예시**: 0/0, −1 등.
    
    ⇒ 둘의 차이는 무한대는 지수가 모두 1이고 가수가 0인 경우, 
        NaN은 지수가 모두 1이고 가수가 0이 아닌 경우. 
    
    ### 5️⃣반올림이 도입된 이유
    
    - **배경**: 실수를 표현하는 비트 수가 제한되어 있어, 모든 소수를 정확하게 표현할 수 없음. 
    이로 인해 반올림이 필요함.
    
    종류 : 
    
    - **최근접 반올림 (Round to Nearest)**:
        - 가장 가까운 수로 반올림하는 방식. 예를 들어, 2.5는 3으로, 2.4는 2로 반올림됨.
    - **0으로의 반올림 (Round towards Zero)**:
        - 0에 가까운 쪽으로 반올림하는 방식. 음수와 양수 모두 소수 부분을 버림.
        - **예시**: 2.7 → 2, -2.7 → -2.
    
    최근접 반올림이 더 정확한 계산에 필요할 때 사용, 0으로의 반올림이 더 간단하고 빠르게
    
    계산할 때 사용. 
    
    ### 6️⃣예외 처리
    
          ⇒ 예외 처리는 부동소수점 연산에서 발생할 수 있는 특수한 상황을 처리하기 위한 방법입니다.
              ex) 오버플로우, 언더플로우, 분모가 -일 때 등등 
    
    ✔️**오버플로우 (Overflow)**:
    
    - 표현할 수 있는 값의 최대치를 초과하는 경우.
    - 매우 큰 수를 곱하거나 더해서 결과가 표현 범위를 넘는 경우.
    
    ✔️**언더플로우 (Underflow)**:
    
    - 표현할 수 있는 값의 최소치보다 작은 경우.
    - 매우 작은 수를 나누거나 빼서 결과가 표현 범위를 벗어나는 경우.
    
    ✔️**NaN (Not a Number)**:
    
    - 연산 결과가 정의되지 않거나 의미가 없을 때 발생.
    - 0/0, −1 (실수 범위에서 정의되지 않은 연산).
    
    ✔️**무한대 (Infinity)**:
    
    - 연산 결과가 매우 큰 값이 되어 표현 범위를 넘는 경우.
    - 1/0, 매우 큰 수의 덧셈 연산.
    
    ✔️**디바이즈 바이 제로 (Divide by Zero)**:
    
    - 0으로 나누는 연산에서 발생.
    - 어떤 수를 0으로 나누는 경우.
    
    ### 7️⃣ 덴오디드 숫자 (Denormalized Numbers)
    
          ⇒ 덴오디드 숫자는 매우 작은 수를 표현하기 위한 방법으로, 지수가 최소값(모두 0)인 경우에,            가수가 0이 아닌 숫자 이는 정규화된 부동소수점 숫자로 표현할 수 없는 작은 수를 다루기 위해 사용
    
    - **사용 목적**: 정규화된 부동소수점 숫자로 표현할 수 없는 매우 작은 수를
    
           표현하기 위해 필요합니다.
    
    - **장점**: 덴오디드 숫자는 작은 수의 정밀도를 높이고, 언더플로우가 발생하는 범위를 줄임.
    - **사용 예시**: 
    **과학적 계산**: 매우 작은 수의 정밀한 표현이 필요할 때 사용.
    
            **금융 계산**: 작은 금액의 처리에서 사용.
    
            **하드웨어 구현**: 덴오디드 숫자를 지원하여 정밀도를 유지.
    
    </aside>
    <br><br>
    
    ❓ 우리가 짜는 코드에서 실수들로는 실제와 차이가 없는 정확한 방법이 없나 ?<br><br>
    
    <aside>
    💡 🥰 라이브러리 쓰면됨. 
           ⇒ JAVA              : BIGDECIMAL을 사용가능하고 
           ⇒ JAVASCRIPT : big.js  
           ⇒ PYTHON        : decimal모듈 사용.
    
    </aside>
    <Br>
    <aside>
    💡 BIGDECIMAL….이란
    
    - **정수와 소수의 분리**: 
    `BigDecimal`은 내부적으로 숫자를 정수와 소수로 분리하여 **10진수로 저장**합니다.
    - **불변 객체**: 
    `BigDecimal` 객체는 불변(immutable)임.
     즉, 한 번 생성되면 그 값을 변경할 수 없음. 
    모든 연산은 새로운 `BigDecimal` 객체를 반환.
    - **정밀도와 반올림 모드**: 
    `BigDecimal`은 연산 시 정밀도와 반올림 모드를 명시적으로 설정할 수 있음. 
    이를 통해 원하는 정밀도와 반올림 방식을 유지할 수 있음.
    
    ### 1. **왜 `BigDecimal`을 사용해야 하나요?**
    
    - **답변**: `BigDecimal`은 부동소수점 연산에서 발생할 수 있는 정밀도 문제를 방지하기 위해 사용특히 금융 계산과 같이 정확한 소수점 연산이 필요한 경우에 유용함. 
    `float`와 `double`은 이진 표현 방식으로 인해 소수점 연산에서 오차가 발생할 수 있지만, `BigDecimal`은 10진수 기반으로 연산을 처리하여 이러한 오차를 방지.
    
    ### 2. **`BigDecimal`의 동작 원리는 무엇인가?**
    
    - **답변**: `BigDecimal`은 내부적으로 숫자를 정수와 소수로 분리하여 10진수로 저장함. `BigDecimal` 객체는 불변 객체로, 한 번 생성되면 그 값을 변경할 수 없음. 모든 연산은 새로운 `BigDecimal` 객체를 반환하며, 연산 시 정밀도와 반올림 모드를 명시적으로 설정할 수 있음.
    
    ### 3. **`BigDecimal`의 주요 메서드는 무엇이 있나요?**
    
    - **답변**: `BigDecimal`의 주요 메서드로는 
    `add()`, `subtract()`, `multiply()`, `divide()` 등이 있음. 
    또한, `setScale()`을 사용하여 소수점 자리수를 설정할 수 있으며, 
    `MathContext`와 `RoundingMode`를 통해 정밀도와 반올림 모드를 지정할 수 있음.
    
    ### 4. **`BigDecimal`의 생성 방법에는 어떤 것들이 있나요?**
    
    - **답변**: `BigDecimal`은 문자열, 정수, 실수 등을 인자로 받아 생성할 수 있음. 
    문자열로 생성하는 것이 가장 안전한 방법임. 
    예를 들어, `new BigDecimal("123.456")`와 같이 생성할 수 있습니다.
    ⇒ 부동소수점을 근사값으로 저장하기 때문에 문자열이 정확하게 저장할 수 있음.
    
    ### 5. **`BigDecimal`의 불변성(immutability)은 어떤 장점을 가지고 있나요?**
    
    - **답변**: `BigDecimal`의 불변성은 객체가 한 번 생성되면 변경되지 않음을 의미함. 
    이는 스레드 안전성을 보장하며, 여러 연산에서 객체의 상태가 변경되지 않도록 함.
     따라서, 동시성 문제가 발생하지 않으며, 코드의 예측 가능성과 신뢰성을 높임.
    </aside>