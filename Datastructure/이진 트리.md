# 이진 트리

**이진 트리**는 각 노드가 최대 두 개의 자식을 가지는 계층적 데이터 구조이다.

<br>

### 이진 트리 표현하기

배열을 통해 표현이 가능하다.

선형구조인 배열로 계층구조인 이진 트리를 표현하기 위해선 3가지 규칙이 필요하다.

1. 루트 노드는 배열 인덱스 1번에 저장한다.
2. 왼쪽 자식 노드의 배열 인덱스는 **부모 노드의 배열 인덱스 x 2**이다.
3. 오른쪽 자식 노드의 배열 인덱스는 **자식 노드의 배열 인덱스 x 2 +1** 이다.

<br>

<aside>
💡만약 루트 노드를 인덱스 0으로 하면 왼쪽 자식 노드의 배열 인덱스는 부모 노드의 배열 인덱스 x 2 +1이 되고, 오른쪽 자식 노드의 배열 인덱스는 부모 노드의 배열 인덱스 x 2 +2가 된다.

</aside>

<br>

![image.png](/Datastructure/img/tree_1.png)

| idx | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 값 |  | 1 | 4 | 8 | 3 | 5 |  | 7 | 2 |  |  |  |  |  | 6 |

트리를 배열로 표현하면 위의 표와 같이 빈 값이 많이 보인다.

노드들이 부모-자식 관계를 곱셈 연산하면서 인덱스로 사용하기 떄문에 실제 노드 개수보다 많은 공간을 사용할 수 밖에 없다. 

<br>

### 이진 트리 순회하기

이진 트리에서 순회는 3가지 방법이 있다.

- **전위 순회** : 현재 노드를 부모 노드로 생각했을때 부모 노드 → 왼쪽 노드 → 오른쪽 노드 순으로 순회
(**트리를 복사할때 사용**)
- **중위 순회** : 현재 노드를 부모 노드로 생각했을때 왼쪽 노드 → 부모 노드 → 오른쪽 노드 순으로 순회
(**정렬된 순서대로 값을 가져올때 사용**)
- **후위 순회** : 현재 노드를 부모 노드로 생각했을때 왼쪽 노드 → 오른쪽 노드 → 부모 노드 순으로 순회
(**트리를 삭제할때 사용**)

<br>

![image.png](/Datastructure/img/tree_2.png)

전위 순회일 경우 : 1 → 4 → 3 → 2 → 5 → 8 → 7 → 6

중위 순회일 경우 : 2 → 3 → 4 → 5 → 1 → 8 → 6 → 7

후위 순회일 경우 : 2 → 3 → 5 → 4 → 6 → 7 → 8 → 1

<br>

### 이진 트리 탐색하기

이진 트리는 자식노드가 최대 2개인 트리를 말하며 데이터 크기를 따져 크기가 작으면 왼쪽에, 크기가 크면 오른쪽에 배치한다. 만약 데이터가 3 → 6 → 2 → 8 → 9 → 7 → 1 순서로 들어오면 트리는 이런 모양을 가진다.

![image.png](/Datastructure/img/tree_3.png)

첫번째 들어온 값인 3을 루트 노드로 시작해서 다음 값인 6은 루트 노드인 3보다 크므로 오른쪽에 배치 그 다음 값인 2는 루트 노드인 3보다 작으므로 왼쪽에 배치한다. 이런식으로 계속 배치하면 된다.

트리를 구축했으니 트리를 탐색해보자

만약 5를 찾고 싶을경우에는 루트 노드 부터 시작해 찾아 나간다.

- 5는 3보다 크니 오른쪽
- 5는 6보다 작아 왼쪽을 보니 더이상 노드가 없다.

2번의 비교 연산으로 값이 없다는것을 알아 냈다.

만약 배열로 5를 찾으려고 한다면 모든 배열을 조회해야 하므로 7번의 연산이 필요할것이다.

이런 점에서 배열탐색보다 이진탐색이 훨씬 빠르다.

<br>

### 이진 트리의 시간 복잡도

이진 트리의 시간 복잡도는 트리 균형에 의존한다.

균형이란 각 노드의 차수가 비슷하게 유지되면서 각 노드의 자식 노드 수가 비슷하게 유지 되는것을 말한다. 균형이 유지된 이진 트리의 시간 복잡도는 **O(logN)** 이다. 하지만 불균형한 트리는 **O(N)** 의 시간 복잡도를 가진다. 

<br>

### 배열로 표현한 이진트리 순서

```java
public class binarytree {

  public static String[] solution(int[] nodes){
    String[] result = new String[3];
    result[0] = preorder(nodes, 0).trim();
    result[1] = inorder(nodes, 0).trim();
    result[2] = postorder(nodes, 0).trim();
    return result;
  }
  
  private static String preorder(int[] nodes, int idx){
    if(idx >= nodes.length) return "";
    
    // 루트 노드 -> 왼쪽 노드 -> 오른쪽 노드 순으로 재귀 호출하여 결과를 이어 붙임
    return nodes[idx] + " " +
        preorder(nodes, 2 * idx + 1) + 
        preorder(nodes, 2 * idx + 2);
  }
  
  private static String inorder(int[] nodes, int idx){
    if(idx >= nodes.length) return "";

    // 왼쪽 노드 -> 루트 노드 -> 오른쪽 노드 순으로 재귀 호출하여 결과를 이어 붙임
    return inorder(nodes, 2 * idx + 1) +
            nodes[idx] + " " +
            inorder(nodes, 2 * idx + 2);
  }
  
  private static String postorder(int[] nodes, int idx){
    if(idx >= nodes.length) return "";

    // 왼쪽 노드 -> 오른쪽 노드 -> 루트 노드 순으로 재귀 호출하여 결과를 이어 붙임
    return postorder(nodes, 2 * idx + 1) +
            postorder(nodes, 2 * idx + 2) +
            nodes[idx];
  }
  

}

```

순회 메서드들에서는 배열의 끝에 도달했을 때, 즉 `idx >= nodes.length`가 되면 빈 문자열 `""`을 반환하고 함수 호출을 종료한다.

`preorder()`

전위 순회는 **부모 노드** → **왼쪽 자식 노드** → **오른쪽 자식 노드** 순서로 방문한다.

1. 현재노드를 먼저 방문한다. (현재 노드가 부모 노드이다.) 
2. 그 후, **왼쪽 자식 노드를 재귀적으로 호출**한다. 왼쪽 자식 노드의 인덱스는 `2 * idx + 1`이다. 예를 들어, 부모 노드의 인덱스가 0이면, 왼쪽 자식은 1이 된다. 
3. 왼쪽 자식을 모두 방문한 후, **오른쪽 자식 노드를 재귀적으로 호출**한다. 오른쪽 자식 노드의 인덱스는 `2 * idx + 2`이다. 예를 들어, 부모 노드의 인덱스가 0이면, 오른쪽 자식은 2가 된다.
재귀 호출이 반복되면서 트리의 모든 노드를 전위 순회 방식으로 방문한다.
<br>

`inorder()`

중위 순회는 **왼쪽 자식 노드 → 부모 노드 → 오른쪽 자식 노드** 순서로 방문한다.

1.  **왼쪽 자식 노드를 먼저 재귀적으로 방문**한다. 먼저 왼쪽 서브트리를 모두 방문한 후, 현재 노드로 돌아온다.
2. 그 후, **현재 노드를 방문**한다.
3. 마지막으로 **오른쪽 자식 노드를 재귀적으로 방문**한다.

<br>

`postorder()`
후위 순위는  **왼쪽 자식 노드 → 오른쪽 자식 노드 → 부모 노드** 순서로 방문한다.
1. 왼쪽 자식 노드를 먼저 재귀적으로 방문
2. 그 후 **오른쪽 자식 노드를 재귀적으로 방문**
3. 마지막으로 **현재 노드를 방문**