# Docker란?

![Untitled](/Docker/img/docker(1).png)

<br>

##  Docker란?

> Docker는 컨테이너 기반 오픈소스 가상화 플랫폼이다.

한 마디로 어플리케이션을 패키징할 수 있는 Tool 이라고 할 수 있다. <br>
`Container`라고 불리는 유닛 안에 
Application, System Tool 툴, dependency 등등을 포함하여 <br>
어떤 OS에서도 안정적으로 작동할 수 있도록 도와주는 Tool!!!

<br>

## 가상화란?

하나의 단일 물리적 컴퓨터의 자원을 분할하여 여러 대의 컴퓨터가 실행되는 것처럼 보이게 하는 기술이다.

<br>


그렇담 가상화가 등장한 배경을 알아보자

<br>

## 가상화가 등장한 배경

![Untitled](/Docker/img/docker(2).png)

<br>

**Traditional Deployment**

![Untitled](/Docker/img/docker(3).png)


    초기의 애플리케이션 배포 환경에서는 
    여러 애플리케이션이 하나의 컴퓨터와 하나의 운영체제에서 실행되었다. 단일 하드웨어만 관리하면 되기 때문에 간단하지만, 각 애플리케이션에 대한 자원 제한을 정의하고 적용할 수 없다는 문제점이 있다.

    하나의 애플리케이션이 갑자기 사용량이 급증하여 CPU와 메모리를 모두 사용해버리면, 같은 서버에서 실행 중인 다른 애플리케이션들은 자원 부족으로 인해 느려지거나 작동을 멈출 수 있다.

    이 문제를 해결하기 위해 각 애플리케이션을 개별 하드웨어에 배포하면 되지만, 이는 자원을 낭비하고 비용이 많이 든다. 이러한 한계를 극복하기 위해 가상화 기술이 등장했다.

<br>



**Virtualized Deployment**

![Untitled](/Docker/img/docker(4).png)


    가상화는 하나의 물리적 컴퓨터를 여러 가상 머신(VM)으로 나누어 애플리케이션을 독립적으로 실행할 수 있게 한다. 이는 하이퍼바이저가 운영체제(OS) 위에서 실행되어 VM을 생성하고 관리하기 때문에 가능하다.

    각 VM은 독립된 OS를 가지므로 애플리케이션이 격리되어 한 애플리케이션이 다른 애플리케이션에 영향을 주지 않는다. 또한, 가상화를 통해 자원 낭비를 방지할 수 있다. 각 VM이 자체 OS를 가지기 때문에 다양한 OS를 실행할 수 있다는 장점들이 있다.

    하지만 각 OS는 많은 메모리와 디스크를 필요로 하며, 이로 인해 오버헤드가 발생할 수 있다. 또한, 호스트 OS(기존 OS)와 게스트 OS(VM OS)가 동일하더라도, 각 OS는 별도로 업데이트해야 하므로 자원이 낭비될 수 있다. 
    
이러한 문제를 해결하기 위해 컨테이너 기술이 등장했다.


<br>

**Container Deployment**

![Untitled](/Docker/img/docker(5).png)

    컨테이너는 애플리케이션을 실행하는 데 필요한 모든 파일을 패키징하고 격리하는 기술이다. 가상 머신과 달리, 컨테이너는 호스트 OS(기존 OS)를 공유한다. 컨테이너 런타임 엔진이 OS 위에서 실행되어 컨테이너를 생성, 배포 및 관리한다. 컨테이너 런타임 엔진은 각 컨테이너를 격리하고 관리하여 다른 컨테이너와의 간섭을 방지한다.

    컨테이너는 애플리케이션과 그 종속성을 패키징하여 동일한 개발 환경을 어디서나 재현할 수 있게한다.  하지만 컨테이너는 호스트 OS와 공유해야 하므로, 반드시 호스트 OS와 같은 종류의 OS를 실행해야한다. 
    
### 😕  VM, Container 둘의 차이점 !!

VM은 운영체제를 포함했다면, <br>
컨테이너는 운영체제를 포함하지 않고 이 컨테이너 엔진이 설치된 Host OS를 공유합니당. 
따라서, VM에서 경량화된 컨셉이라고 할 수 이쬬.<br>
<br>
컨테이너가 구동되기 위해서는 컨테이너 런타임 엔진이 필요하고, <br>
이 컨테이너 런타임 엔진이 Host OS에 접근해서 필요한 것들을 처리해줍니당. 


컨테이너 런타임 엔진중 가장 유명한 오픈소스가 바로 **Docker**이다.

<br><br>

# 그럼 이제 도커란 무엇이고 어떻게 구성되어 있는지 봅니당. 

Docker는 총 3단계를 거칩니다.

1. 컨테이너 만들고 → 2. 구동하고 → 3. 배포하기 

### 1️⃣ 컨테이너를 만들기

![스크린샷 2024-08-21 오후 6.34.07.png](/Docker/img/docker(7).png)

→ 컨테이너를 만들기 위해서는 총 3가지가 필요해용.

`도커파일, 이미지, 컨테이너` 입니당. 

우선!!

`도커파일`

![스크린샷 2024-08-21 오후 6.35.14.png](/Docker/img/Docker(8).png)

쉽게 말해 설명서입니당. 
어플리케이션을 구동하기위해 꼭 필요한 파일은 무엇이있는지

어떤 프레임워크나 라이브러리를 설정해야하는지 <br>
외부 dependency , 어떻게 구동할 수 있는지 
script 등등을  포함해용. 

이렇게 작성한 도커파일을 이용해서 `이미지` 를 만들 수 있다. 

![스크린샷 2024-08-21 오후 6.35.51.png](/Docker/img/Docker(9).png)

이미지 안에는 어플리케이션을 실행하기 위해 필요한 코드, 런타임 환경, 시스템 라이브러리 등등의 모든 환경을 가지고 있다. 

이 실행 상태를 찰칵 찍어서 이미지로 만든다는 것이다. 
이미지는 변경 불가능한 `불변상태`입니당. 

`컨테이너` 는 

![스크린샷 2024-08-21 오후 6.37.27.png](/Docker/img/Docker(10).png)

샌드박스처럼 우리가 잘 캡쳐해둔 우리 어플리케이션의 이미지를 고립된 환경에서 개별적인 파일시스템 안에서 실행할 수 있는 것을 이야기 한다. 

컨테이너안에서 어플리케이션이 동작한다 !!

고로, 이 컨테이너는 이 이미지를 이용해서 어플리케이션을 구동하게 되는 것이다. 

## 여기까지 컨테이너 생성에 대해서 이야기했고, 이제는 어떻게 구동할 수 있는지를 이야기 해보겠슴다.

엄밀히 말하면 어떻게 이미지를 공유할 수 있는 지에 대해서 이야기 할 것이다. 

### 2️⃣ Docker Container 구동하기

![스크린샷 2024-08-21 오후 6.40.57.png](/Docker/img/Docker(11).png)

    2_1. 내 로컬 머신에서 이미지를 만들어서 

    2_2. github와 같은 Container Registry에 내가 만든 이미지를 푸시하고 

    2_3. 필요한 서버나, 다른 개발자 PC에서내가 만든 이미지를 가지고와서 그걸 그대로 실행하면 된당. 

물론 실행하기 위해서는 도커와 같은 컨테이너 엔진을 꼭 설치해두어야 한당. 

우리가 이미지를 업로드 할 수 있는  Container Registry에는 

public과 private이 있는데

![스크린샷 2024-08-21 오후 6.42.04.png](/Docker/img/Docker(12).png)

도커허브를 많이 쓴다. !!
회사는 대부분 private를 한다. 
당연히 보안적인 측면 때문이당. 

총 정리 

![스크린샷 2024-08-21 오후 6.43.20.png](/Docker/img/Docker(13).png)

1. 개발하고있는 로컬 머신에 도커 설치 
2. 서버에도 도커 설치 
3. 이제 내 로컬 머신에서 도커파일 작성하고 이걸 이용해서 이미지를 만들고
4. 이미지를 컨테이너 레지스트리에 올린다음에 
5. 서버에서 다운(pull)받아서 컨테이너를 실행할 수 있다. !!

### 3️⃣ 배포하기

# 끝!!

이렇게 3가지의 경로로 볼 수 있다. ㅎㅎ
총 정리 해볼게용
<br>


## Docker 구성 요소



**1. Docker Client**

Docker CLI를 사용해 사용자가 Docker와 상호작용하며, 명령어를 통해 Docker 데몬과 통신하여 
`이미지를 빌드`, `컨테이너를 실행`, `이미지를 레지스트리에서 가져오는 작업` 등을 수행

<br>

**2. Image**

Docker 컨테이너를 생성하기 위한 읽기 전용 템플릿이다. 이미지는 소스코드, 라이브러리, 종속성, 도구 등 어플리케이션을 실행하기 위해 필요한 파일을 포함한 `불변파일`이다. 

자바의 클래스라고 생각하면 이해하기 편하다.

<br>

**3. Container**

이미지로 부터 생성된 실행 가능한 인스턴스이다. 
각 컨테이너는 독립된 환경에서 애플리케이션을 실행하며, 필요한 라이브러리 및 설정을 포함한다.

마찬가지로 자바의 클래스를 통해 생성된 객체라고 생각하면 편하다.

<br>

**4. Dockerfile**

Docker 이미지를 빌드하는 방법을 정의하는 스크립트 파일이다.

<br>

**5. Docker registries**

Docker 이미지를 저장하고 배포하는 저장소이다.  Docker Hub는 누구나 사용할 수 있는 공개 레지스트리이며 Docker는 기본적으로 Docker Hub([https://hub.docker.com/](https://hub.docker.com/)**)**에서 이미지를 찾는다. `docker pull` 을 사용하여 registry에서 필요한 이미지를 가져온다.

<br>

**6. Docker Demon**

Docker 데몬(dockerd)은 Docker API 요청을 수신하고 이미지, 컨테이너 같은 Docker 객체를 관리한다.

<br>


## Docker 아키텍처

![Untitled](/Docker/img/docker(6).png)

Docker 아키텍처는 클라이언트-서버 모델을 기반으로 하며, 구성 요소들은 서로 상호 작용하여 컨테이너 기반 애플리케이션의 개발, 배포 및 관리를 가능하게 한다.

- **클라이언트 명령어 실행**
    - 사용자가 Docker CLI에서 `docker run`, `docker build`, `docker pull` 등의 명령어를 실행한다.
- **Docker 데몬과 통신**
    - Docker CLI는 Docker 데몬과 통신하여 명령어를 전달한다. Docker 데몬은 이를 처리하여 적절한 작업을 수행한다.
- **이미지 빌드 및 실행**
    - `docker build` 명령어는 Dockerfile을 사용하여 이미지를 빌드한다.
    - `docker run` 명령어는 빌드된 이미지를 기반으로 컨테이너를 시작한다.
- **이미지 다운로드 및 업로드**
    - `docker pull` 명령어는 Docker 레지스트리로부터 이미지를 다운로드한다.
    - `docker push` 명령어는 이미지를 Docker 레지스트리에 업로드한다.
- **컨테이너 관리**
    - Docker 데몬은 이미지를 사용하여 컨테이너를 생성하고, 시작, 중지, 삭제 등의 작업을 수행한다.
- **레지스트리와의 상호작용**
    - Docker 데몬은 이미지를 다운로드하거나 업로드하기 위해 Docker 레지스트리와 통신한다.


<br><br><br><br><br>

### Reference

[https://docs.docker.com/guides/docker-overview/#docker-objects](https://docs.docker.com/guides/docker-overview/#docker-objects)
[https://kubernetes.io/ko/docs/concepts/overview/](https://kubernetes.io/ko/docs/concepts/overview/)