# [HTTP] 쿠키, 세션, JWT


<br>
기본적으로 웹 브라우저는 HTTP 기반으로 동작하고있다.

HTTP는 `무상태(Stateless)` 구조로 <mark>서버가
클라이언트의 상태를 유지하지 않는다.</mark>

그렇기 때문에 서버는 클라이언트의 정보를 저장하지 않아 클라이언트를 구별 할 수 없고 <br>
클라이언트는 매번 인증을 진행해야한다.

이러한 문제를 해결하기 위한 방법들이 있다.
바로 `쿠키, 세션` 이다. <br>=> 기본적으로 stateful하다
<br> => 뒤에 나올 `JWT`는 session의 단점을 보완하기 위해 나온  기법으로 
stateless하다. 
<br>

---


# 쿠키(Cookie) 내가 만든 쿠킹~

쉽게 말해 쿠키는 내 브라우저에 저장되어 있는 정보로  <br>
어떤 사이트에 방문할 때 내가 들고다니는 정보입니당. <br>
(따라서, 내가 수정할 수 있고 남들도 쉽게 볼 수 있다)
> 웹서버가 생성하는 데이터를 담는 작은파일
> 

![출처:[https://ko.wikipedia.org/wiki/HTTP_쿠키#/media/파일:HTTP_cookie_exchange.svg](https://ko.wikipedia.org/wiki/HTTP_%EC%BF%A0%ED%82%A4#/media/%ED%8C%8C%EC%9D%BC:HTTP_cookie_exchange.svg)](/Web/img/cookie(1).png)


<br>

1. 브라우저(클라이언트)에서 웹서버로 요청을 보낸다.
2. 요청을 받은 서버는 응답 데이터와 쿠키를 함께 응답한다.
3. 응답을 받은 쿠키를 브라우저의 메모리에 저장하고 브라우저에서 서버로 요청을 다시 보낼때 브라우저(클라이언트)의 정보를 가지고있는 쿠키를 서버에 보낸다.

<br>

쿠키에는 클라이언트의 정보를 담고 있으므로 서버는 쿠키에 담긴 정보를 토대로 데이터를 응답한다. 

⭐ `중간에 서버가 장애가 나도` 쿠키에 브라우저의 정보를 담고있으므로 다른 서버에 쿠키를 보내면 `이상없이 작업을 이어나갈 수 있다` .

이렇게 쿠키는 stateless 구조를 구현하고있다. <br>
쿠키의 사용 예로는 `자동 로그인`, `쇼핑몰 장바구니` 등이 있다.

<br>

### 쿠키의 한계 ㅠㅠ

자동로그인 같이 사용자의 개인정보를 쿠키로 저장 할 시 <br>
로컬파일에 저장되므로 쉽게 `조작되거나 중간에 가로챌 수 있는` 위험이 있다. <br>
=> 따라서, 회원의 중요한 정보는 담지 않는 것이 정석!!

<br><br>

---

# 세션(session)

> 클라이언트가 브라우저의 접속하고 서버와 접속이 종료되기 전의 상태
> 
 

기본적으로 세션은 쿠키를 기반으로 사용하고있다.

![출처:[https://dongsik93.github.io/til/2020/01/08/til-authorization(1)](https://dongsik93.github.io/til/2020/01/08/til-authorization(1)/)](/Web/img/session(1).png)

<br>

1. 사용자가 로그인을 위해 아이디, 비밀번호를 서버에 요청 (Post)
2. 서버에선 회원 DB에 로그인한 사용자를 조회한다.
3. 사용자가 등록된 회원이라면 세션DB에 회원 정보 세션을 생성한다.
4. 세션 저장소에선 세션ID를 생성해 서버에 반환한다.
5. 반환된 세션ID를 서버에서 쿠키에 담아 사용자에게 응답한다.
6. 사용자가 서버로 부터 응답받은 쿠키(세션ID)를 브라우저에 저장하고, 이후 다른 페이지를 이동하거나 새로이 요청을 한다면 쿠키(세션ID)를 담아 보낸다.
7. 요청을 받은 서버는 쿠키에 담긴 세션ID를 세션DB에서 조회한다.
8. 세션ID에 해당하는 회원 정보를 반환한다.
9. 마지막으로 서버에서 사용자에게 회원정보를 바탕으로 데이터를 응답한다.

간단하게 요약하자면, 

    1. 클라이언트에서 서버로 로그인 요청을 날리면 session 티켓이라는 것을 발급 후 반으로 찢음. 
    
    2. 찢은 반에 sessionId라고 하는 것을 사용자의 브라우저 쿠키에 저장. 

    3. 반은 서버의 메모리나 하드디스크나 레디스 등에 저장. 

    4. 로그인 후 사용자가 어떤 서비스를 서버에 요청하면 사용자 브라우저 내부 쿠키에 있는 sessionId와 DB에 있는 sessionId가 일치하는지 검사 후, 일치하면 정보 반환. 
<br><br>

### 세션의 장단점

쿠키만 사용했을 때는 `보안이 취약하다는 단점`이 있었다.

세션에서의 쿠키는 단순히 세션ID를 넘기는 매개체로 역할을 할뿐이다.

⭐ 장점 : <br>
=> 모든 회원의 정보는 DB에 저장되어있으므로 <mark>보안상 훨씬 안전</mark>하다.

⛔ 단점 : <br>
=> 세션정보를 조회하는 과정이 있어 많은 요청이 있으면 많은 시간과 자원이 든다.<br>
=> 만약, 메모리에 세션 정보를 담아둔다면, 서버가 에러가 나는 순간 데이터가 다 날아간다. <br>
=> 혹은, 서비스가 어느 정도 규모가 있어서 서버를 여러 대 두고 운영을 한다면, 로그인은 1번 서버, 이메일 요청은 3번으로 가면 
사용자의 sessionId가 정확한 위치에 없어서 어렵다. <br>

    따라서, 이 sessionId를 레디스나 공용서버에 담아두기는 한다. 
    => 이 역시 에러가 나면 데이터가 날아가는 것은 여전하다. 
    이를 고안하기 위해서 나온 방법이 "JWT" 이다. 
<br><br>

## JWT를 하기 전에 세션과 JWT를 알기 위해서는 인증과 인가에 대한 개념을 알아야 한다. 

<b style="color : yellow">인증(Authentication) :</b>
<br>쉽게 말해 `로그인` 입니당. <br>
내가 이 사이트를 가입한 회원임을, 아이디 패스워드 등을 통해 인증을 받는 것 <br>

<b style="color : yellow">인가(Authorization) : </b>
<Br>
이렇게 인증을 받은 사용자가 내 계정으로만 할 수 있는 활동을 시도 할 때 그 사이트가 내 아이디를 알아보고 허용을 해주는 것. <br>
ex)내 계정으로 게시글 쓰기, 내 게시글로 좋아요 누르기

JWT는 `인가`에 관련된 기술입니당. 

❓ ❓  어떤 사이트에 사용자가 `로그인해있다는 사실`을 알릴 방법이 뭐가 있을까용 ? <Br>
=> 만약, 매 요청마다 브라우저에 아이디 비번을 담아서 확인을 한다면 
1. DB에 있는 해시암호화된 회원의 비밀번호를 다시 풀어서 일치하는 과정을 매번 반복해야함.
2. 보안상의 위험 

=> 따라서 !!
전통적으로 가장 많이 쓴 방식이 
session 이다. <br>
=> 
    앞에서 기재했지만,,, 한 번 더 정리하자면 session은 session 표딱지라는 것을 발급해 반으로 찢어 하나는 사용자의 브라우저 쿠키 안에 세션 ID를 저장, 하나는 서버의 메모리나 하드디스크 등등에 sessionID와 그에 대한 정보를 저장하고, 
    브라우저가 서버에 요청을 보낼 시에 이 sessionId로 인증을 해서 그에 맞는 정보를 반환하는 방식이다. 

session은 이야기 드렸듯이, `메모리 부족`이나 `데이터가 날아가는 현상` 때문에 이를 보안하기 위한 방법이 `JWT`이다. 




---

## JWT(Json Web Token)

> Json객체를 이용한 토큰 기반 인증 시스템 <br>
=> 토큰 방식은, JWT사용자가 로그인을 했을 때 `토큰` 이라고 하는 표를 출력해서 건네준다. <br>이번에는 클라이언트와 나눠가지지 않는다. <br>
즉, 서버는 아무 것도 기억하지 않는다. (토큰만 제공, stateless)


<br>

### JWT 구조

![Untitle](/Web/img/jwt(1).png)
=> 보면 ~~~. ~~~. ~~~ 으로 구성이 되어있는데 이 부분을 각각 <br>
`Header` (헤더), `Payload`(페이로드), `Signature`(서명)라고 부른다.


<br>

**Header**

![Untitle](/Web/img/jwt(2).png)

> Header는 Signature(서명)를 해싱하기 위한 정보를 담고있다.
> 
- alg  : 암호화 알고리즘 (중요함 알고리즘 약자)
- tpy : 토큰 유형 (JWT로 고정값임)

alg 에는 3번의 서명값을 만드는 데 사용될 알고리즘이 지정된다. <br>
HS256등 여러 암호화 방식 중 하나를 지정할 수 있다. <br>
`1번 헤더` + `2번 페이로드` + `서버에 감춰놓은 비밀값`을 <br>
이 암호화 알고리즘에 넣고 돌리면 3번 서명값이 나온다. 

<br>

**Payload**

![](/Web/img/jwt(3).png)

> 서버와 클라이언트가 주고받는 실제 데이터를 담고있다. <Br>
=> 이걸 Base64로 디코딩 해보면 JSON형식으로 여러 정보들이 들어있다. <br>
=> 이 토큰을 누가 누구에데 발급했는지, 이 토큰이 언제까지 유효한지,
그리고 서비스가 사용자에게 이 토큰을 통해 공개하기 원하는 내용 (사용자의 닉네임, 서비스상의 레벨, 관리자 여부 등)서비스 측에서 원하는 대로 내용을 담을 수 있당. <br>
=> 이렇게 토큰에 담긴 사용자 정보 등의 데이터를 claim 이라고 한당. <Br>
=> 사용자가 가지고 있는 정보마다 이런 정보가 있으면 서버가 일일이 DB를 뒤져보지 않아도 된당. 

 ❓ ❓ 근데 그럼 조작하면  ❓ ❓ <br>
=> 그래서 1번과 뒷 부분 3번이 있는거다.<Br>
말했듯이, 1,2번 값과 함께 서버의 비밀키를 암호화로 돌린 값이 3번의 서명값이기 때문이당. 

1. 3번 서명값과 계산값이 일치하고 , 
2. 유효기간도 지나지 않았다면 
3. 그 사용자는 로그인 된 회원으로서 인가를 받는 것이당. 

<br>

**Signature**

![출처: [https://jwt.io/]](/Web/img/jwt(4).png)

> 토큰의 유효성을 검증을 위한 문자열을 담고있다.


Header 와 Payload를 base64 Url Safe Encode 결과와 서버의 개인키와 합친 후 Header에 정의한 
암호화 알고리즘으로 암호화한다.

<aside>

=> 결과적으로 JWT는 Stateless 하고 session은 stateful 하다. 


💡  **base64 Url Safe?**

</aside>

base64는 문자들을 base64형태(ASCII)로 변환하여 전송하고 받는쪽은 다시 변환하여 하는 방법이다 하지만 마지막 62,63번 글자가 “+” 와 “/”이기 때문에 문자가 정상적으로 전송되지 않는 문제가 발생하는데  62,63번 글자를 “-” 와 “_” 로 변경한것을 **base64 Url Safe**이다.

<br><br>

### 토큰 인증 과정

![](/Web/img/jwt(5).png)

1. 클라이언트가 서버에 로그인 요청(ID, password)
2. 서버측에서 인증 요청이 오면 암호화된 JWT를 생성해 쿠키에 담아 클라이언트에게 응답한다.
3. 클라이언트에서 응답받은 JWT를 저장한다.(localStorage, cookie)
4. 이후 클라이언트는 JWT를 사용하여 서버에 요청한다.
5. 서버는 요청 온 JWT를 유효한 토큰인지 검사를 한다.
6. 만약 토큰이 유효하지 않거나 만료되었다면 오류를 반환한다.
7. 토큰이 유효하다면 클라이언트의 요청 데이터를 응답한다.


##  ❓ ❓그럼 JWT가 짱짱맨이니 session은 안 써도 되는거냐 ??!!?

=>.... 아니요... 큰 결함이있습니다. <br>

    session 처럼 사용자의 모든 정보를 기억하고 있다는 것은 구현하기 부담스러우나, 되기만 하면 기억하는 대상의 상태들을 언제든 제어 가능함. 

    ex) 예를 들어 한 기기에서만 로그인 할 수 있도록 지정한다고 해서 한 사용자가 PC에서 로그인 했으면, 핸드폰에서 또 로그인 하면 PC에서는 로그아웃 할 수 있도록 기존 세션을 종료할 수 있는 거죵. 
        
    근데.. JWT는 이미 준 토큰을 다시 뺏을 수도 없고 서버가 어디 기록해서 추적하는 것도 아니니 통제하기도 어렵다. 

더 심각한 건 어떤 토큰이 탈취해버리면 <mark>무효화 할 방법은 없다</mark>. 

=> 그래서 나름 보완하기 위해 나오는 구현 방법이 refresh token 발급방법이다. 그게 무엇이냐 ! <br>

사용자가 로그인을 하고 나면 `토큰을 두 개를 주는 거다`. 
1. 수명이 몇 시간이나 몇 분 이하로 짧은 access 토큰
2. 2주 ~1년까지 길게 잡힌 refresh 토큰 

    
    둘을 발급하고 클라이언트에게 보내고나서 , refresh토큰은 상응값을 database에도 저장. <br>
    
    손님은 access토큰이 수명이 다하면, refresh 토큰을 보낸다. <br>
서버는 그걸 DB에 저장된 값과 대조해보고, 맞으면 새 access토큰을 발급해주는 것. 

=> 이렇게 하면 누구를 강제 로그아웃 시킬라면 <Br>
=> refresh Token을 삭제하면 되는 것이다. <Br>
그래도 access토큰이 살아있는 동안은 없앨 수 없다... 

 ## ❓ ❓ 아니 근데 refresh token도 탈취 당할 수 있는거아님 ?

HttpOnly 속성은 웹 브라우저가 쿠키를 클라이언트 측 스크립트(JavaScript 등)에서 접근할 수 없도록 설정하는 옵션임. <br>
이 속성이 설정된 쿠키는 오직 HTTP(S) 요청을 통해서만 전송되고, JavaScript로는 접근할 수 없습니다.

=> 따라서, 이를 함께 기재해주자..... 