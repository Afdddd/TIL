# 웹브라우저에 url 입력 후 일어나는 일


<br>

### 1. 웹 브라우저에 URL을 입력하고 Enter 키 입력

```
https://www.naver.com
```

위의 URL을 살펴보면

<br>

`https` : 통신 프로토콜 . HTTPS는 Hypertext Transfer Protocol Secure의 약자로 HTTP에 SSL/TLS를 적용한 프로토콜로, 웹 페이지나 웹 애플리케이션이 안전하게 데이터를 주고받을 수 있게 해준다.

<br>

[`www.naver.com`](http://www.naver.com) : 도메인 이름이다.

<br><br>

### 2. DNS 조회

사용자가 브라우저 주소창에 URL을 입력하고 Enter를 누르면, 브라우저는 우선 **도메인 이름**을 실제 서버의 **IP 주소**로 변환해야 한다.이 과정은 DNS(Domain Name System)를 통해 이루어진다.

<br>

DNS는 인터넷에서 사용되는 **도메인 이름을 IP 주소로 변환**해주는 시스템이다. 사람이 쉽게 기억할 수 있는 웹 주소( `www.naver.com`)를 컴퓨터가 이해할 수 있는 **IP 주소**(`223.130.195.95`)로 변환하는 역할을 한다.

DNS 조회를 빠르게 하기 위해 **DNS 캐시**가 사용된다. DNS 캐시는 브라우저부터 네트워크 계층의 여러 단계에 걸쳐 존재하며, 도메인에 대한 IP 주소를 저장하고 재사용함으로써 같은 요청에 대해 빠르게 응답할 수 있도록 한다. 

먼저 브라우저는 캐시에 저장된 DNS 정보를 찾습니다. 브라우저 캐시에 정보가 없으면 운영 체제의 **호스트 파일**을 확인합니다. Windows의 경우 `C:\Windows\System32\drivers\etc\hosts`에 위치하고, Linux의 경우 `/etc/hosts`에 위치합니다.

브라우저 캐시와 운영 체제 캐시에도 정보가 없다면, **라우터**의 캐시, 그리고 ISP(인터넷 서비스 제공자)의 **DNS 서버**에서 해당 도메인 이름을 조회하게 됩니다.

**ISP의 DNS 서버**에서도 도메인 정보가 없을 경우, 요청은 **상위 DNS 서버**로 전달됩니다. 이 과정에서 **루트 DNS 서버**, **TLD(Top-Level Domain) DNS 서버**, 그리고 **권한 있는(authoritative) DNS 서버**까지 단계적으로 조회하여 최종적으로 IP 주소를 찾게 됩니다.

이렇게 브라우저는 도메인에 해당하는 **IP 주소**를 획득하게 된다.

<br><br>

### 3. TCP 연결

브라우저는 서버의 IP 주소를 알게 되면, 해당 서버와 연결을 설정하기 위해 **TCP 연결**을 시도한다. 이때 **TCP/IP 프로토콜**을 사용하여 신뢰성 있는 데이터 전송을 보장하기 위해 **3-way 핸드셰이크** 과정을 수행한다.

<br>

**3-way 핸드셰이크**:

1. **SYN**: 브라우저(클라이언트)는 서버에 연결 요청을 나타내는 **SYN** 패킷을 전송
2. **SYN-ACK**: 서버는 클라이언트의 요청을 받고, 연결 요청을 수락하는 **SYN-ACK** 패킷을 클라이언트에게 응답
3. **ACK**: 클라이언트는 서버의 응답을 확인하고, 최종적으로 **ACK** 패킷을 서버에 전송하여 연결을 설정

이 후 브라우저에서 보낸 요청 패킷은 인터넷을 통해 서버로 이동한다. 이때 **라우터**와 **인터넷 서비스 제공자(ISP)의 스위치**를 통해 여러 네트워크 장비를 거쳐 최종 목적지인 서버로 전송된다.

이 과정에서 IP(Internet Protocol)는 네트워크 상의 데이터를 목적지까지 정확하게 전송하기 위해 **라우팅 테이블**을 사용하여 가장 적절한 경로를 선택한다.

<br>

**CDN(Content Delivery Network)**

하지만 사용자가 입력한 웹 서버의 위치가 물리적으로 멀리 떨어져 있는 경우, 브라우저와 서버 간의 연결 속도가 느려질 수 있다. 이러한 문제를 해결하기 위해 많은 웹사이트들이 **CDN**을 사용한다.

**CDN**은 인터넷 사용자에게 콘텐츠를 더 빠르게 제공하기 위해 **분산된 서버 네트워크**를 사용한다. 

- 사용자가 특정 웹 사이트에 접속할 때, 그 콘텐츠가 물리적으로 멀리 있는 서버에 저장되어 있으면 데이터를 전송하는 데 시간이 많이 걸린다. 예를 들어, 사용자가 한국에 있고 웹 서버가 미국에 있다면 데이터 전송 시간이 길어지고 지연이 발생할 수 있다.
- **CDN**은 이러한 문제를 해결하기 위해 여러 지역에 엣지 서버(Edge Server)를 분산 배치하여 콘텐츠를 캐싱한다. 엣지 서버는 사용자가 요청한 콘텐츠(정적 및 동적 콘텐츠)를 미리 저장해두고, 사용자와 물리적으로 가까운 서버에서 데이터를 제공해준다.

CDN은 자주 요청되는 콘텐츠를 미리 캐싱해둠으로써, 사용자가 해당 콘텐츠를 요청할 때 원래 서버까지 가지 않고 가까운 CDN 서버에서 빠르게 응답받을 수 있도록 한다. 이를 통해 **버퍼링** 없이 동영상을 보거나 음악을 들을 수 있는 것이다.

<br><br>

### 4. HTTP 요청 전송

<br>

TCP 연결이 설정된 후, 브라우저는 서버에 **HTTP 요청**을 보낸다. 이 요청은 웹 페이지나 특정 리소스를 가져오기 위한 것이다. **HTTP/HTTPS**는 브라우저와 서버 간의 통신 규칙을 정의하는 프로토콜입니다.

**HTTP 요청의 구성**:

1. **요청 라인(Request Line)**:
    - **요청 메서드(Method)**: 클라이언트가 서버에게 수행하기를 원하는 작업을 지정합니다. 대표적인 메서드로는 **GET, POST, PUT, PATCH, DELETE** 등이 있다.
    - **경로(Path)**: 요청하는 리소스의 경로를 지정합니다. 예를 들어, `/news/1620`은 특정 뉴스 게시물에 대한 경로이다.
    - **HTTP 버전(Version)**: 요청에 사용할 HTTP 프로토콜의 버전을 지정합니다. 예를 들어, `HTTP/1.1`을 사용할 수 있다.
2. **요청 헤더(Request Headers)**:
- 요청에 대한 메타데이터를 포함한다. 예를 들어, **Host** 헤더는 요청의 대상 서버를 지정하고, **User-Agent** 헤더는 클라이언트(브라우저)의 정보를 포함한다.

3. **요청 바디(Request Body)**:
- `GET` 요청에서는 요청 바디가 없지만, **POST, PUT, PATCH**와 같은 메서드에서는 클라이언트가 서버로 전송하고자 하는 데이터를 포함한다. 이 데이터는 보통 양식 데이터, JSON, XML 등의 형식으로 포함된다.

<br><br>

### **5. 웹 서버의 요청 처리 및 응답 생성**

서버는 클라이언트로부터 받은 HTTP 요청을 처리합니다.

1. **요청 분석**:
    - 서버는 요청 라인, 헤더, 바디의 내용을 분석하여 클라이언트가 어떤 리소스를 요청하는지 파악합니다.
    - 예를 들어, `GET /blog/1620 HTTP/1.1` 요청이 오면, 서버는 `/blog/1620` 경로에 해당하는 리소스를 찾습니다.
2. **응답 생성**:
    - 서버는 요청에 대한 **응답(Response)**을 생성합니다. 이 응답에는 다음과 같은 요소가 포함됩니다:
        - **상태 라인(Status Line)**: 요청 처리 결과를 나타냅니다. 예를 들어, `HTTP/1.1 200 OK`는 요청이 성공적으로 처리되었음을 나타냅니다.
        - **응답 헤더(Response Headers)**: 응답에 대한 정보를 포함합니다. 예를 들어, `Content-Type`은 응답 데이터의 타입을 명시합니다.
        - **응답 바디(Response Body)**: 요청한 리소스를 포함합니다. 예를 들어, HTML, CSS, JavaScript, 이미지 등이 포함될 수 있습니다.
3. **상태 코드**:
    - **200 OK**: 요청이 성공적으로 처리되었음을 의미합니다.
    - **404 Not Found**: 요청한 리소스를 찾을 수 없음을 의미합니다.
    - **500 Internal Server Error**: 서버 내부에서 오류가 발생했음을 의미합니다.

<br><br>

### **6. 브라우저의 콘텐츠 렌더링**

브라우저는 서버로부터 받은 응답을 사용하여 페이지를 렌더링합니다. 이 과정에서 HTML, CSS, JavaScript 등이 사용되며, 사용자가 웹 페이지를 시각적으로 볼 수 있도록 합니다.

1. **HTML 파싱 및 DOM 트리 생성**:
    - 브라우저는 응답 바디에 포함된 **HTML 문서**를 **파싱**하여 **DOM 트리**를 생성합니다. **DOM(Document Object Model)**은 HTML 문서를 계층적 구조로 표현한 것입니다.
2. **CSS 파싱 및 CSSOM 트리 생성**:
    - HTML을 파싱하는 동안 **CSS** 파일이 참조되면, 브라우저는 이를 추가적인 **HTTP 요청**을 통해 가져옵니다.
    - CSS를 파싱하여 **CSSOM(CSS Object Model) 트리**를 생성하고, DOM 트리와 결합하여 **렌더 트리(Render Tree)**를 만듭니다.
3. **JavaScript 실행 및 DOM 조작**:
    - HTML 문서에 **JavaScript** 파일이 포함되어 있다면, 브라우저는 이를 로드하여 실행합니다.
    - JavaScript는 DOM을 조작하고, 페이지의 동적 동작을 담당합니다. 예를 들어, 버튼 클릭 시 이벤트 핸들러를 통해 DOM의 내용을 변경할 수 있습니다.
4. **페인팅(Painting)과 합성(Compositing)**:
    - 브라우저는 렌더 트리를 기반으로 페이지의 각 요소를 **페인팅**하여 화면에 표시합니다.
    - 복잡한 레이아웃의 경우 요소들을 여러 **레이어(layer)**로 나누어 **합성(compositing)**을 통해 화면에 그립니다. 이를 통해 애니메이션이나 스크롤 등 복잡한 동작이 더 부드럽게 처리됩니다.