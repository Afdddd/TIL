# MSA란

![Untitled](/Architecture/img/MSA(1).png)

### 마이크로서비스 아키텍처(Microservice Architecture, MSA)

> 소프트웨어 시스템을 여러 개의 독립적인 서비스로 나누어 개발하는 방법이다.

<br>

각각의 서비스는 비즈니스 기능을 수행하고, 다른 서비스와는 **독립적**으로 배포, 확장, 유지보수가 가능하다.

<br>

### **MSA의 장점**

- **확장성 :** 각 서비스를 독립적으로 확장할 수 있어서, 애플리케이션이 증가된 트래픽과 부하를 더 쉽게 처리할 수 있다.
- **개발 속도 향상** : 각 서비스를 독립적으로 개발, 테스트, 배포할 수 있어서 개발 주기가 짧아진다.
- **안정성** : 각 서비스가 독립적이기 때문에, 한 서비스의 실패가 다른 서비스에 영향을 미치지 않는다.
- **유연성** :  서비스를 특정 요구에 가장 적합한 기술을 사용하여 개발할 수 있어서 기술 선택의 유연성이 높아진다.
- **타사 서비스와의 쉬운 통합**: 각 서비스는 자체 API를 통해 개발될 수 있어서 타사 서비스와 쉽게 통합할 수 있다.

<br>

### MSA의 단점

- **복잡성 증가**: 마이크로서비스 아키텍처는 여러 서비스가 서로 통신해야 하므로 전통적인 모놀리식 아키텍처보다 복잡하다.
- **분산 시스템 문제**: 마이크로서비스 아키텍처는 여러 서버에 서비스를 분산시킬 수 있어서 데이터 일관성, 네트워크 지연, 서비스 발견과 관련된 문제가 발생할 수 있다.
- **테스트 및 디버깅 문제**: 마이크로서비스 아키텍처에서는 여러 서비스를 독립적으로 테스트 및 디버깅해야 할 뿐만 아니라 서비스 간 통합 테스트도 수행해야 하므로 더 복잡하다.
- **관리 오버헤드**: 마이크로서비스 아키텍처에서는 여러 서비스를 관리하는 데 추가적인 오버헤드가 발생한다. 여기에는 배포, 확장 및 모니터링이 포함된다.

<br>

**마이크로서비스는 언제 사용하는가?**

마이크로서비스 아키텍처는 높은 수준의 확장성, 가용성 및 민첩성을 요구하는 복잡한 대규모 애플리케이션에 적합한 선택입니다. 또한 여러 타사 서비스 또는 시스템과 통합해야 하는 조직에도 적합할 수 있습니다.

<br>

### MSA 통신

모놀로식 어플리케이션의 통신은 프로세스 내 통신으로 이루어진다. 

모든 구성 요소가 단일 프로세스 내에서 동작하며 메소드 호출을 통해 서로 통신하는 것을 의미한다.

반면, MSA는 분산 시스템이다. 각 마이크로 서비스는 자체 프로세스를 가지므로 네트워크 레벨에서 통신을 해야한다. HTTP, gRPC, AMQP 와 같은 프로토콜을 사용한다.

<br>

### 동기 통신

![Untitled](/img/MSA(2).png)

동기 통신은 클라이언트가 요청을 보내고 서비스로부터 응답을 받을 때까지 기다린다. 이는 클라이언트 코드가 서버로부터 응답이 도착할 때까지 스레드를 차단(block)한다는 것을 의미한다.

동기 요청/응답 기반 통신 유형을 사용할 때는 HTTP 프로토콜과 REST 접근 방식을 선호한다. 이는 특히 마이크로서비스 클러스터 외부에 API를 노출할 때 유용하다.

또한, gRPC와 같은 바이너리 통신 메커니즘을 사용할 수도 있다. gRPC는 마이크로서비스 클러스터 내부 통신을 위한 통신 방법 중 하나이다.

<br>

```java
❓마이크로서비스 클러스터란?

클러스터는 그룹을 의미하며, 마이크로서비스 클러스터는 마이크로서비스들의 그룹을 말한다. 

각 마이크로서비스는 독립적인 서비스로, 특정 비즈니스 기능을 수행한다. 
이러한 마이크로서비스들이 모여 전체 애플리케이션을 구성하는 클러스터를 형성한다.

마이크로서비스 클러스터 외부 통신은 사용자와 어플리케이션과의 통신을 의미하고,
마이크로서비스 클러스터 내부 통신은 마이크로 서비스들 간의 통신을 의미한다.
```

<br>

**gRPC란?**

우선 RPC(Remote Procedure Call)는 원격 프로시저 호출을 의미한다. 한 컴퓨터의 프로그램이 네트워크 상의 다른 컴퓨터에서 실행되는 프로그램의 프로시저(함수 또는 메소드)를 호출할 수 있게 하는 프로토콜이다. 

gRPC(원격 프로시저 호출)는 구글에서 개발한 오픈 소스 원격 프로시저 호출(RPC) 시스템이다.

gRPC는 몇 가지 최적화와 함께 기존 RPC를 구현하는 시스템이다. 예를 들어 gRPC는 데이터 전송에 Protocol Buffer와 HTTP/2를 사용한다.

- Protocol Buffers(Protobuf) : 구글에서 개발한 데이터 직렬화 형식으로  JSON이나 XML보다 더 작고 빠른 이진 형식을 사용한다.

<br>

### 비동기 통신

![Untitled](/img/MSA(3).png)

비동기 통신은 클라이언트가 요청보내고 서비스로부터 응답을 받을때 까지 기다리지 않는다.  이는 클라이언트 코드가 서버로부터 응답이 도착할 때까지 스레드를 차단되지 않는것(non-block)을 의미한다.

비동기 통신에서 가장 널리 사용되는 프로토콜은 Advanced Message Queuing Protocol(AMQP)이다. AMQP 프로토콜을 사용하면 클라이언트는 Kafka나 RabbitMQ와 같은 메시지 브로커 시스템을 통해 메시지를 전송한다. 메시지 프로듀서는 일반적으로 응답을 기다리지 않는다. 이러한 메시지는 구독 시스템에 의해 비동기적으로 처리되며, 응답을 기다리는 상황이 발생하지 않는다.

<br>

```java
💡 AMQP? Message Broker? 구독 시스템?

AMQP(Advanced Message Queuing Protocol)는 메시지 지향 미들웨어에서 사용되는 오픈 표준 
응용 계층 프로토콜이다. 즉 메시지 기반의 프로토콜을 말한다.
여기서 말하는 메시지는 하나의 프로그램이 다른 프로그램에 데이터를 전달하기 위해 사용하는 
데이터 단위를 말한다.

Message Broker는 AMQP 프로토콜을 사용하여 메시지를 송수신하고 관리하는 중개 역할을 하는 
시스템이다. 
메시지 브로커는 프로듀서(메시지를 생성하는 시스템)와 컨슈머(메시지를 소비하는 시스템) 
간의 메시지 전달을 중개하는 역할을 한다.

구독 시스템은 메시지 브로커를 통해 전달된 메시지를 구독하고 처리하는 시스템이다.
```

