# RDB와 NoSQL의 차이

<br>

## RDB의 단점

### **확장성의 부족**

RDBMS에서는 새로운 열을 추가할 때 스키마를 수정해야 한다. 특히 대규모 데이터가 저장된 테이블에 열을 추가할 경우, 모든 행에 새로운 열을 반영해야 하므로 성능 저하가 발생할 수 있다. 이것은 데이터베이스에 큰 부하를 줄 수 있다.

예를 들어 학생 관리 시스템에서 학생들의 '주소' 정보를 추가하려고 할 때, 기존의 수백만 건의 학생 데이터를 가진 테이블에 새로운 '주소' 열을 추가하려면 테이블 전체에 영향을 미치기 때문에 성능 문제가 발생할 수있다.

<br>

### 중복을 허용 불가

RDB는 데이터를 정규화하여 중복을 제거하지만, 정규화된 테이블 간 데이터를 통합하려면 조인이 필요하다. 많은 데이터를 처리할 때 조인 작업은 성능을 저하시킬 수 있고, 복잡한 쿼리는 실행 시간이 길어질 수 있다.

<br>

### 수평 확장에 비효율적

RDB는 기본적으로 한 서버에서 실행되며, 성능이 저하될 때 서버의 사양을 높이는 수직 확장을 주로 사용된다. 하지만 이 방식은 서버 성능이 한계에 도달하면 더 이상 확장할 수 없다는 문제가 있다. 수평 확장(서버를 여러 대로 늘리는 방식)은 일반적으로 RDB에서 복잡하며, 복제(replication)와 샤딩(sharding) 등의 기술이 필요하다.

```
- 복제(replication) : 데이터를 동일하게 여러 서버(노드)에 복사하여 저장해 하나의 서버에 장애가 발생하더라도 다른 복제본에서 데이터를 제공할 수 있도록 한다.
- 샤딩(sharding) : 대용량 데이터를 여러 서버에 분할하여 저장하는 방식으로 샤드에는 데이터의 일부만 저장되며, 이러한 분산을 통해 읽기 및 쓰기 성능을 개선할 수 있다.
```

<br>

### ACID 특성으로 인한 성능 저하

[ACID](/DB/ACID.md)란?

RDB는 ACID(Atomicity, Consistency, Isolation, Durability) 특성을 준수하기 때문에 트랜잭션의 무결성과 일관성을 보장한다. 하지만 이러한 특성은 높은 성능을 요구하는 환경에서는 성능을 저하시킬 수 있다. 특히 동시성 처리에서 문제가 발생할 수 있다.

예를 들어 금융 시스템에서 다수의 트랜잭션이 동시에 발생할 경우 독립성을 지키기위해 응답시간이 늘어날 수 있다.


<br><br>

---



## NoSQL의 탄생 배경

<br>

**기존 RDBMS의 한계**

인터넷과 모바일 서비스가 발전하면서 기존의 RDBMS는 대규모 데이터를 처리하는 데 한계가 생겼다. 특히 SNS와 같은 서비스가 등장하면서 RDBMS는 높은 처리량과 낮은 지연 시간(응답 시간)을 요구하는 환경을 감당하기 어려워졌다. 또한, 비정형 데이터(구조가 예측할 수 없는 데이터)의 증가로 인해 더 유연한 데이터 저장소가 필요해졌다.

<br>

**NoSQL등장**

이러한 배경에서 NoSQL이 등장했다. 'Not Only SQL'이라는 의미를 가지고 있고, RDBMS가 처리하지 못하는 요구사항을 해결하기 위해 만들어졌다. NoSQL 데이터베이스는 높은 처리량, 낮은 지연 시간, 비정형 데이터를 유연하게 처리할 수 있는 기능을 제공한다.

MongoDB, Redis, DynamoDB, HBase 등은 대표적인 NoSQL 데이터베이스이다.

<br>
<br>

---


## NoSQL 특징

<br>

### 유연한 스키마(flexible schema)

RDBMS는 테이블의 스키마를 사전에 정의해야 하지만, NoSQL은 스키마를 미리 정의할 필요가 없다. NoSQL에서는 데이터가 JSON 형식으로 저장되며, 유연하게 데이터를 삽입할 수 있다.

기존 student 테이블 생성 방법

```sql
create table student(
	id   INT          PRIMARY KEY,
	name VARCHAR(20),
	...
)
```
<br>

mongoDB의 컬렉션 생성 방법

```sql
db.createCollection("student")
db.student.insertOne({ name: "김철수", age: 20 })
```

이처럼 스키마를 정의하지 않고 데이터를 바로 삽입할 수 있으며, JSON 형식으로 데이터를 조회할 수 있다.

<br>

### 중복 허용

NoSQL은 RDB처럼 정규화를 강요하지 않기 때문에 데이터의 중복을 허용한다. 중복된 데이터를 허용함으로써 조인을 피할 수 있고, 이를 통해 성능을 향상시킬 수 있다. 하지만 데이터의 일관성을 유지하는 책임은 애플리케이션 레벨에서 처리해야 한다.

예를 들어, 전자상거래 시스템에서 제품 정보와 재고 정보를 따로 관리하지 않고 한 컬렉션에 중복된 정보로 저장해 두면, 재고 확인 시 조인 없이 빠르게 데이터를 조회할 수 있다.

<br>

### scale-out에 최적화됨

NoSQL은 여러 서버를 하나의 클러스터로 구성하여 수평 확장을 통해 성능을 높인다. 데이터는 여러 서버에 나누어 저장되며, 필요에 따라 특정 서버에서 데이터를 조회할 수 있기 때문에 효율적이다. RDB와 달리 NoSQL은 중복을 허용하고 데이터가 한 서버에 집중되지 않도록 분산할 수 있어 수평 확장에 용이하다.

MongoDB의 경우 여러 서버에 데이터를 분산 저장하고, 필요한 데이터를 하나의 서버에서만 조회할 수 있어 성능이 향상된다.

```
클러스터란?
클러스터는 여러 대의 컴퓨터(노드)를 연결하여 하나의 시스템처럼 작동하도록 구성한 컴퓨터 그룹이다.
```

<br>

### 높은 처리량

NoSQL은 ACID 중 일부를 포기하고 높은 처리량과 낮은 지연 시간을 추구한다. 특히 일관성보다 가용성을 우선시하는 환경에서 성능이 뛰어나다. 그러나 데이터의 일관성이 중요한 환경(예: 금융 시스템)에서는 RDB를 사용하는것이 더 좋을수있다.

SNS와 같이 실시간으로 많은 데이터를 처리해야 하는 시스템에서 NoSQL은 빠른 응답 속도를 보장할 수 있다.

<br><br>

---

## 주요 차이점

<br>

### **데이터 모델**

- **RDB :** 고정된 스키마를 가지고 있고, 데이터를 테이블의 형태로 저장한다. 각 테이블은 행(Row)과 열(Column)로 구성되어 있고, 각 행은 고유한 데이터를 나타낸다. 스키마가 변경되면 기존 데이터에도 영향을 미친다.

- **NoSQL**: 유연한 스키마를 제공하며, 문서(Document), 키-값(Key-Value), 그래프(Graph) 등의 다양한 데이터 모델을 지원한다. 스키마 변경 없이 다양한 형태의 데이터를 저장할 수 있다.

<br>

### **확장성**

- **RDB** : 수직 확장(Scale-up) 방식으로 주로 사용. 수평 확장(Scale-out)이 어렵다.

- **NoSQL**: 수평 확장(Scale-out)에 최적화되어 여러 서버에 데이터를 분산하여 저장할 수 있다. 클러스터링을 통해 성능을 향상시킬 수 있어 더 많은 데이터와 트래픽을 처리할 수 있다.

<br>

### **조인과 데이터 중복**

- **RDB**: 데이터의 중복을 피하기 위해 정규화된 여러 테이블에 데이터를 분리하여 저장한다. 조인(Join)을 사용해 여러 테이블의 데이터를 통합 조회하는 방식이다. 그러나 복잡한 조인은 성능 저하를 일으킬 수 있다.

- **NoSQL**: 조인을 사용하지 않고, 데이터를 중복하여 저장한다. 조인 대신 중복된 데이터를 사용하여 성능을 최적화하지만, 중복된 데이터의 일관성은 애플리케이션 레벨에서 관리해야 한다.

<br>

### **ACID vs BASE**

- **RDB**: 트랜잭션이 일어날 때 ACID 속성을 준수하여 데이터의 일관성과 무결성을 보장한다. 데이터가 중요한 금융 시스템 등에서 사용된다.

- **NoSQL**: 일부 NoSQL 데이터베이스는 ACID 대신 BASE 원칙을 따른다. 빠른 응답이 중요한 시스템 등에서 사용된다.


<br>

```
BASE원칙이란?
- Basically Available (기본적으로 가용함): 시스템은 언제나 사용할 수 있는 상태를 유지하며, 부분적인 실패가 발생하더라도 전체 시스템이 다운되지 않고 지속적으로 가용성을 유지한다.
- Soft State (소프트 상태): 데이터의 상태는 항상 일관적이지 않지만 , 시간이 지나면서 변경될 수 있다. 즉, 즉각적으로 일관성을 보장하지 않고, 데이터가 변경될 수 있는 상태로 남아있다.
- Eventual Consistency (최종적 일관성): 데이터는 즉각적으로 일관성을 유지하지 않더라도, 시간이 지나면 최종적으로 모든 데이터가 일관된 상태에 도달하게 된다.
```